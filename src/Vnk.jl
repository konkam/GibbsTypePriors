# function Vnk_NGG_old(n, k, β, σ)
#     β_arb = RR(β)
#     σ_arb = RR(σ)
#     return exp(β_arb) * σ_arb^(k-1) // RR(gamma(n)) * sum([binom(n-1, i, RR) * (-1)^i * β_arb ^(i//σ_arb) * real(gamma(k-i//CC(σ_arb), CC(β_arb))) for i in 0:(n-1)])
# end


"""
    Vnk_NGG(n, k, β, σ)

Calculation of the Vnk with arbitrary precision. This function is less accurate for small values of k.

# Examples
```julia-repl
julia> GibbsTypePriors.Vnk_NGG(950,50, 0.5, 0.2)
[3.8352033538906132801013353906868979398003615464023850790896863425714903553677226925055088746374316383109460954810284197859760984821731337318749595774947223616262209073739394021758498274625163338449050351539476265420058089446771803706284551125841735045167180428032503440230421477960661771838407576902892779249509437591900661480877143065301185622812541265406061355208499807014555543564206395963786037047501112201458115571178196894484765277010637093746870221360851774075869753015052347546075947342163011788718201438701670521824067688930574380546890246338996488357288469652851508886233959379599363414674816239620509492570297419371380404876526047019213064592743056547790007323431419320067128517155931031446743616067264862092384235340693861382516829416661260795864740780157957535281924044152165190002256884051072596878645089791000193415582741991189356825795269080464284696216369289690437152742813909679764874302349498025317865584922699306108146943457154750027744867148116339573187411564950371482234809283153942745404958070388914430591794906329509545071131596480723325249062012958207542739071651236894164675019841047663212800147578131631060869316509586195876115342586677261181109184501899398551285655781119232061487943017880727759501463530477776e-2387 +/- 8.27e-3625]
```
"""
function Vnk_NGG(n, k, β, σ)
    β_arb = RR(β)
    σ_arb = RR(σ)
    n_m_1_Flint = FlintZZ(n-1)
    return exp(β_arb) * σ_arb^(k-1) // RR(gamma(n)) * sum(binomial(n_m_1_Flint, FlintZZ(i)) * (-1)^i * β_arb ^(i//σ_arb) * real(gamma(k-i//CC(σ_arb), CC(β_arb))) for i in 0:(n-1))
end
#
# function Vnk_NGG2(n, k, β, σ)
#     gamma_n::arb = gamma(n)
#     return exp(β) * σ^(k-1) // gamma_n * sum([binom(n-1, i, RR) * (-1)^i * β^(i//σ) * real(gamma(k-i//CC(σ), CC(β))) for i in 0:(n-1)])
# end
# function Vnk_NGG3(n, k, β, σ)
#     gamma_n::arb = gamma(n)
#     return exp(β) * σ^(k-1) // gamma_n * sum(binom(n-1, i, RR) * (-1)^i * β^(i//σ) * real(gamma(k-i//CC(σ), CC(β))) for i in 0:(n-1))
# end
# function Vnk_NGG4(n, k, β, σ)
#     gamma_n::arb = gamma(n)
#     n_m_1_Flint = FlintZZ(n-1)
#     return exp(β) * σ^(k-1) // gamma_n * sum(binomial(n_m_1_Flint, FlintZZ(i)) * (-1)^i * β^(i//σ) * real(gamma(k-i//CC(σ), CC(β))) for i in 0:(n-1))
# end


# @memoize function Vnk_NGG_rec(n, k, β, σ)
#     # println("n = $n, k = $k")
#     if n < 100 || k ≥ n/2
#         return Vnk_NGG(n, k, β, σ)
#     else
#         return (Vnk_NGG_rec(n-1, k, β, σ)-Vnk_NGG_rec(n, k+1, β, σ))/RR(n-1-σ*k)
#     end
# end

@memoize function Vnk_NGG_rec(n, k, β, σ)
    res = Vnk_NGG(n, k, β, σ)
    if has_reasonable_precision(res)
        return res
    else
        println("n = $n, k = $k, Accuracy = $(accuracy_bits(res))")
        return (Vnk_NGG_rec(n-1, k, β, σ)-Vnk_NGG_rec(n, k+1, β, σ))/RR(n-1-σ*k)
    end
end


"""
    Vnk_2PD(n, k, θ, σ)

Calculation of the Vnk for a 2-parameter Poisson-Dirichlet (also known as Pitman-Yor) process with arbitrary precision. 

# Examples
```julia-repl
julia> GibbsTypePriors.Vnk_2PD(7, 6, 0.5, 0.01)
[1.9770514285714285829380091500954323693644674824124026984992171309957729383892396509600074280486078176779783843427919567657142584744842411272863181245428808578583616597575557259694224232057348431696299003094318048035523344218002322698832143887862395401395274358633297792959324407688665501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501165501e-5 +/- 2.28e-1510]
```
"""
function Vnk_2PD(n, k, θ, σ)
    θ_arb::arb = RR(θ)
    σ_arb::arb = RR(σ)
    if k==1
        num::arb = arb_1
    else
        num = prod([θ_arb + i * σ_arb for i in 1:(k-1)])
    end
    return num // risingfac(1+θ_arb,n-1)
end
